---
layout: post
title: Java虚拟机-学习笔记
date: 2017-11-13
categories: blog
tags: [学习笔记]
description: 
---

# 一、类加载器子系统


# 二、运行时数据区
![Java虚拟机运行时数据](img/jvm/2-1-0.png)

#### 所有线程共享数据区
1、方法区（Method Area）
用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
还包括运行时常量池。

2、JAVA堆（JAVA Heap）--内存最大的一块
所有的对象实例以及数组都要在堆上分配

#### 线程之间隔离的数据库
3、计数器(PC)
每个线程都有单独的PC寄存器，用于保存当前执行指令的地址，一旦指令执行，PC寄存器将更新到下一条指令。
4、本地方法栈

5、JVM栈(JVM Stack)



# 三、执行引擎



# 四、其他
### 4.1、为什么要分代
分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。
试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。


### 4.2、
New Generation 可用的GC
Serial: 这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Serial收集器是虚拟机运行在Client模式下的默认新生代收集器。

Parallel Scavenge：它也是使用复制算法的收集器，又是并行的多线程收集器。Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。自适应（会动态调整SurvivorRatio的大小,也可以固定).

ParNew：ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样。ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器。配合使用老年代的CMS

Old Generation 可用的GC
Serial Old : Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记－整理算法。Serial Old收集器的主要意义也是在于给Client模式下的虚拟机使用。

Parallel Old：Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。

CMS：CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤：

初始标记（CMS initial mark）：初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。
并发标记（CMS concurrent mark）：并发标记阶段就是进行GC Roots Tracing的过程。
重新标记（CMS remark）：重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，仍然需要“Stop The World”。
并发清除（CMS concurrent sweep）：并发清除阶段会清除对象。
由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。另外CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生，同时也会产生大量的空间碎片

G1：G1（Garbage-First）是一款面向服务端应用的垃圾收集器。G1收集器的运作大致可划分为以下几个步骤：

初始标记（Initial Marking）：初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。
并发标记（Concurrent Marking）：并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。
最终标记（Final Marking）：最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面。最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。
筛选回收（Live Data Counting and Evacuation）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。

YoungGC
YoungGC会在eden region的数量达到阈值（或者说eden空间满的时候）的时候触发。YoungGC期间，所有的young regions（eden和survivor）都会被收集。所有的存活对象都会被复制到一块新的survivor region或者老年代 region。如果复制空间不够，将使用一块新的available region作为survivor或者老年代 。这一过程也称为evacuation pause。




